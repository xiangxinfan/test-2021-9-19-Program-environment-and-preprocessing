#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//程序环境和预处理

//本章重点
//程序的翻译环境
//程序的执行环境
//详解：C语言程序的编译+链接
//预定义符号介绍
//预处理指令 #define
//宏和函数的对比
//预处理操作符#和##介绍
//命令定义
//预处理指令 #include 
//预处理指令 #undef
//条件编译




//正文：

//程序的翻译环境和执行环境
  //在ANSI的任何一种实现中，存在两个不同的环境
      //第一种是翻译环境，在这个环境中源代码被转换为可执行的机器指令
      //第二种是执行环境，它用于实际执行代码
//机器语言就是0和1的二进制代码
//在PDF中都有相应的图



//编译环境：
//流程大概是：很多个源文件经过编译器的处理生成目标文件，再有很多个目标文件都经过同一个
    //链接器进行编译成为可执行程序

//这个例子用到了add.c文件

//extern int Add(int x, int y);//这是一个函数声明，声明到Add这个函数中
//int main()
//{
//    int a = 10;
//    int b = 20;
//    int arr[10] = { 0 };
//    int i = 0;
//    for (i = 0; i < 10; i++)
//    {
//        arr[i] = i;
//    }
//    for (i = 0; i < 10; i++)
//    {
//        printf("%d ", arr[i]);
//    }
//    printf("\n");
//    int c = Add(a, b);//这里就会自动转到add.c文件中，但这样还是需要一个文件声明。就跟函数声明一样
//    printf("c=%d\n", c);
//    return 0;
//}



//翻译环境为test.c，运行环境是test.exe
//翻译环境包括：编译（编译器），链接（链接器）
//编译中又包括：预编译，编译和汇编

//1、#include 头文件包含，2、注释删除，使用空格来替换注释，3、#define（文本替换）
//这三个都是进行的是文本操作

//把C语言代码翻译成汇编语言  的  几点注意：
//1、语句分析，2、词法分析 3、语义分析  4、符号汇总      //这其中都是编译原理中会讲到的

//链接会这样：    1、合并段表
             //   2、符号表的合并和符号表的重定位   




//运行环境：
//程序执行的过程：

//1、程序必须载入内存中，在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序
   //的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。
//2、程序的执行便开始。接着调用main函数
//3、开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回
   //地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程
   //一直保留他们的值
//4、终止程序。正常终止main函数，也可能是意外终止。



//预处理讲解


//预定义符号：
//   __FILE__       //进行编译的源文件
//   __LINE__       //文件当前的行号
//   __DATE__       //文件被编辑的日期
//   __TIME__       //文件被编译的时间
//   __STDC__       //如果编译器遵循ANCI C标准，其值为1，否则未定义

//这些预定义符号都是语言内置的。



//int main()
//{
//    printf("%s\n", __FILE__);//文件的地址
//    printf("%d\n", __LINE__);//第108行
//    printf("%s\n", __DATE__);
//    printf("%s\n", __TIME__);//获取时间
//    return 0;
//}


////写日志文件
////记录时间，不打印到屏幕上，但可以记录到文件中去
////主要来记录相关时间
//int main()
//{
//    int i = 0;
//    int arr[10] = { 0 };
//    FILE* pf = fopen("log.txt", "w");
//    for (i = 0; i < 10; i++)
//    {
//        arr[i] = i;
//        fprintf(pf, "file:%s line:%d data:%s time:%s i=%d\n", 
//            __FILE__, __LINE__, __DATE__, __TIME__, i);
//    }
//    fclose(pf);
//    pf = NULL;
//
//    for (i = 0; i < 10; i++)
//    {
//        printf("%d ", arr[i]);
//    }
//    return 0;
//}//在文档log中就可以查到


//int main()
//{
//    printf("%d\n", __STDC__);//这个预编译符号VS不支持，但是gcc编译器下是支持的
//    return 0;
//}



//#define

//#define 定义标识符

//#define MAX 100
//#define STR "haha"
//int main()
//{
//    int max = MAX;//就是将MAX替换成100
//    printf("%d\n", max);
//    printf("%s\n", STR);
//    return 0;
//}

//#define reg register   //为register这个关键字，创建一个简短的名字
//#define do_forever for(;;)   //用更形象的符号来替换一种实现
//#define CASE break;case      //在写case语句的时候自动把break写上
////如果定义的stuff过长，可以分几行写，除了最后一行外，每行的后面都加上一个反斜杠（续航符）
//#define DEBUG_PRINT printf("file:%s\tline:%d\t   \
//                            date:%s\ttime:%s\n",\
//                            __FILE__,__LINE__,  \
//                            __DATE__,__TIME__)



//问：在#define 中定义标识符的时候，要不要在最后加上；？
//比如：#define MAX 100；

//建议不要加上，这样容易导致问题
//比如：

//#define MAX 100;
//int main()
//{
//    int max = MAX;//相当于
//    //int max = 100;;//相当于这个样子，就会导致错误
//    //这就成了空语句，可能就会报错
//    //printf("%d\n", MAX);//这就出现了错误，而且不容易找出来，相当于printf("%d\n", 100;);
//    printf("%d\n", max);
//    return 0;
//}

//尽管带分号看似没有问题，但总会有哪一部分就不知不觉出现了错误



//#define 定义宏


//#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或
//定义宏（define macro）

//下面是宏的申明方法:
//#define name(parament-list) stuff//name与后面的括号之间不能有空格
//其中parament-list是一个由逗号隔开的符号表，它们可能出现在stuff中。

//注意：参数列表的左括号必须与name紧邻。如果两者之间有任何空白存在，参数列表就会被解释为stuff
//的一部分。

//例如：
//#define SQUARE(X) X*X   //其中SQUARE就是宏
//int main()
//{
//    int ret = SQUARE(5);//这其实就是相当于
//    //int ret = 5 * 5;
//    printf("ret = %d\n", ret);
//    return 0;
//}

////当时5+1的时候
//int main()
//{
//    int ret = SQUARE(5 + 1);
//    printf("ret=%d\n", ret);
//    return 0;//这里的答案是11
//    //因为这里的宏相当于
//    //int ret = 5 + 1 * 5 + 1;//于是结果就为11
//}


//#define DOUBLE(X) X+X
//int main()
//{
//    int a = 5;
//    int ret = 10 * DOUBLE(a);
//    //这里就相当于10*5+5；
//    printf("ret=%d\n", ret);
//    return 0;
//}

////而我所想要的结果为100.则就要在宏这里加括号：
//#define DOUBLE(X) (X+X)
//int main()
//{
//    int a = 5;
//    int ret = 10 * DOUBLE(a);
//    //这回这里就相当于10*（a+a)
//    printf("ret=%d\n", ret);
//    return 0;
//}


//注意事项：加括号时，要注意括号加到够为止，不要加的太多，以免一些不必要的麻烦


//提示：所以用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，避免在使用宏时由于参数
//中的操作符或邻近操作符之间不可预料的相互作用。



//#define 替换规则
//在程序中扩展#define定义符号和宏时，需要涉及几个步骤：

//1、在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先
  //被替换。
//2、替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换。
//3、最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述
  //处理的过程。

//注意：

//1、宏参数和#define定义中可以出现其他#define定义的变量。但对于宏，不能出现递归。
//2、当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索。




//#和##
    //如何把参数插入到字符串中？



//void print(int a)
//{
//    printf("the value of a is %d\n", a);
//}
//int main()
//{
//    int a = 10;
//    int b = 20;
//    print(a);
//    print(b);//这里应该是b等于20，而结果却是a等于20
//    return 0;
//}

//但是函数是解决不了这件事情


////这就相当于：
//int main()
//{
//    printf("hello world\n");
//    printf("hello ""world\n");
//    printf("hel""lo " "world\n");//这就可以理解为就是故意创造条件，是这几个字符串连接在一起
//    return 0;
//}//这打印出来的都是一样的

//我们发现字符串是有自动连接的特点的。


////#define PRINT(X) printf("the value of X is %d\n",X)//这打印出来是the value of X is 10/20
//#define PRINT(X) printf("the value of "#X" is %d\n",X)//使用 # ，把一个宏参数变成对应的字符串。
////#X 就自动转换成a
//int main()
//{
//    int a = 10;
//    int b = 20;
//    PRINT(a);//这就相当于
//    //printf("the value of a is %d\n", a);
//    PRINT(b);
//    //printf("the value of b is %d\n", b);
//    return 0;
//}

//上面就是#的作用


//##的作用

   //##可以把位于它两边的符号合成一个符号。它允许宏定义从分离的文本片段创建标识符。

//#define CAT(X,Y) X##Y
//int main()
//{
//    int Class20 = 2019;
//    //printf("%d\n", class);
//    printf("%d\n",CAT(Class,20));//这里括号里面必须要跟第329行保持一致，就想后面的20就不能改成21
//    //相当于
//    //printf("%d\n", Class##物联);
//    //printf("%d\n", Class物联);
//    return 0;
//}

//注意： 这样的连接必须产生一个合法的标识符。否则其结果就是未定义的。



//带副作用的宏参数

//当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能
//导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。
//例如：

//x+1;  //不带副作用的
//x++;  //带有副作用的


//MAX宏可以证明具有副作用的参数所引起的问题

//int main()
//{
//    int a = 10;
//    int b = a + 1;//1
//    //这里就是将b改变之后不改变a
//    int b = ++a;//2
//    //这里将b改变之后还将a改变了，成遗留的副作用
//    return 0;
//}



//#define MAX(X,Y) (X > Y ? X : Y)
//int main()
//{
//    int a = 10;
//    int b = 11;
//    int max = MAX(a++, b++);//这就相当于：
//    //int max = ((a++) > (b++) ? (a++) : (b++));
//    
//    printf("%d\n", max);//12//这里都是++之后出来的结果进行比较的
//    //b>a,所以应该输出b，但是b++了，所以输出的就是12
//    printf("%d\n", a);//11
//    //a++之后的结果
//    printf("%d\n", b);//13
//    //max中++之后，运行到这里的时候再进行++了
//    return 0;
//}




//宏和函数对比

//宏通常被应用于执行简单的运算。

//可以用函数来解决，也可以用宏来解决

//1、用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。
  //所以宏比函数在程序的规模和速度方面更胜一筹。
//2、更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。
  //反之这个宏怎可以适用于整型、长整型、浮点型等可以用于>来比较的类型。宏是类型无关

//当然和宏相比函数也有劣势的地方:
//1、每次使用宏的时候，一份宏定义的代码将插到程序中。除非宏比较短，否则可能大幅度增加程序的
   //长度。
//2、宏是没法进行调试的
//3、宏由于与类型无关，也就不够严谨
//4、宏可能会带来运算符优先级的问题，导致程容易出现错。

//宏有时候可以做函数做不到的事情。比如：宏的参数可以出现类型，但是函数做好。


//下面这个就是啊上面函数和宏的区别

////函数 -1
//int Max(int x, int y)
//{
//    return (x > y ? x : y);
//}
//float Max2(float x, float y)
//{
//    return (x > y ? x : y);
//}
////宏 -2
//#define MAX(X,Y) (X>Y?X:Y)
//int main()
//{
//    int a = 10;
//    int b = 20;
//    float c = 3.0f;
//    float d = 4.0f;
//    //int max = Max(a, b);
//    //int max = Max(c, d);
//    int max = Max2(c, d);
//    printf("max=%d\n", max);
//    //max = MAX(a, b);
//    max = MAX(c, d);
//    printf("max=%d\n", max);
//    return 0;
//}//这只是表明不同的变量类型都可以用同一个宏来搞定
////所以这就是证明函数只能传个int型的值过去，而不能传int类型过去

//#define SIZEOF(type) sizeof(type)
//int main()
//{
//    int ret = SIZEOF(int);
//    int ret1 = sizeof(int);//这两个等价
//    printf("%d\n", ret);
//    printf("%d\n", ret1);
//    return 0;
//}




//#include <stdlib.h>
//#define MALLOC(num,type) (type*)malloc(num*sizeof(type))
//int main()
//{
//    int* p = (int*)malloc(10 * sizeof(int));
//    //这里就需要传类型，但是函数就不可以，宏就可以解决
//    int* p1 = MALLOC(10, int);//这就相当于
//    //int* p1 = (int*)malloc(10 * sizeof(int));
//    return 0;
//}







//  属性              #define定义宏                               函数
 
//代码长度         每次使用时，宏代码都会被插        函数代码只出现于一个地方；每次使
//                 入到程序中，除了非常小的宏        用这个函数时都会调用那个地方的同
//                 之外，程序的长度会大幅度增        一份代码       
//                 长

//执行速度         更快                              存在函数的调用和返回的额外开销，
//                                                   所以相对慢一些

//操作符优先级     宏参数的求值是在所有周围表        函数参数只在函数调用的时候求值一
//                 达式的上下文环境里，除非加        次，它的结果值传递给函数。表达式
//                 上括号，否则邻近操作符的优        的求值结果更容易预测
//                 先级可能会产生不可预料的后
//                 果。所以建议宏在书写的时候
//                 多加括号。

//带有副作用       参数可能被替换到宏体中的多        函数参数只在传参的时候求值一次，
//的参数           个位置，所以带有副作用的参        结果更容易控制
//                 数求值可能会产生不可预料的
//                 结果

//参数类型         宏的参数与类型无关，只要对        函数的参数是与类型有关的，如果参
//                 参数的操作是合法的，它就可        数的类型不同，就需要不同的函数。
//                 以使用于任何参数类型              即使他们执行的任务是不同的

//调试             宏是不方便调试的                  函数可以逐语句调试

//递归             宏是不能递归的                    函数是可以递归的




//命名约定
//一般来讲函数和宏的使用语法很相似。所以语言本身没法帮我们区分二者，那我们平时的一个习惯是：

//把宏名全部大写  函数名不要全部大写




//#undef
//这条指令用于移除一个宏定义


//#undef NAME
//如果现存的一个名字需要被重新定义，那么它的旧名字首先要被移除。



//命令行定义

//许多C的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。例如：当我们根据同
  //一个源文件要编译出不同的一个程序的不同版本的时候，这个特征有点用处。（假定某个程序中声明
  //了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，但是另外一个机器内存大写，
  //我们需要一个数组能够大写）

 //但这个在Linux中看起来比较容易
 

//在C中看起来就很平常，看不出来啥了

//#define ARRAY_SIZE 10
//int main()
//{
//    int array[ARRAY_SIZE];
//    int i = 0;
//    for (i = 0; i < ARRAY_SIZE; i++)
//    {
//        array[i] = i;
//    }
//    for (i = 0; i < ARRAY_SIZE; i++)
//    {
//        printf("%d ", array[i]);
//    }
//    printf("\n");
//    return 0;
//}




//条件编译
  //在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有
//条件编译指令

//比如说：
   //调试的代码，删除可惜，保留又碍事，所以我们可以选择性的编译

//int main()
//{
//    int arr[10] = { 0,1,2,3,4,5,6,7,8,9 };
//    int i = 0;
//    for (i = 0; i < 10; i++)
//    {
//        arr[i] = i;
//#ifdef DEBUG
//        printf("%d ", arr[i]);
//#endif//加上这两条，表明不进行打印
//    }
//    return 0;
//}

//#define DEBUG    //再加上这个，就可以编译了
//int main()
//{
//    int arr[10] = { 0,1,2,3,4,5,6,7,8,9 };
//    int i = 0;
//    for (i = 0; i < 10; i++)
//    {
//        arr[i] = i;
//#ifdef DEBUG
//        printf("%d ", arr[i]);
//#endif//加上这两条，表明不进行打印
//    }
//    return 0;
//}//第578行和580行这两行都是在预处理阶段进行编译的，也叫做预处理指令





//常见的预处理指令

//1、
//#if  常量表达式
       //....
//#endif
//常量表达式由预处理器求值
//如：
//int main()
//{
//    int arr[10] = { 0,1,2,3,4,5,6,7,8,9 };
//    int i = 0;
//    for (i = 0; i < 10; i++)
//    {
//        arr[i] = i;
//#if 1//这个数字这里可以是表达式也可以是数字，都只有一点，就是真值进行执行，假值不执行
//        printf("%d ", arr[i]);
//#endif//604行和606行是一对
//    }
//    return 0;
//}

////2、多分支的条件编译
//#if    常量表达式
//       //....
//#elif    常量表达式
//       //...
//#else    
//       //...
//#endif   
//       //...

//int main()
//{
//#if 1==1
//    printf("haha\n");
//#elif 2==1
//    printf("hehe\n");
//#else
//    printf("heihei\n");
//#endif
//    return 0;
//}

////3、判断是否被定义
//#if  defined(symbol)
//#ifdef  symbol

//if  !defined(symbol)
//#ifndef  symbol






//#define  DEBUG //不定义这个是不会进行打印的
//int main()
//{
//#if defined(DEBUG)
//    printf("hehe\n");
//#endif
//    return 0;
//}


//int main()
//{
//#ifdef DEBUG//这里有define则会编译，否则不会进行编译 
//    printf("haha\n");
//#endif
//    return 0;
//}

//ifdef == if define 


//#define DEBUG
//int main()
//{
//#if !defined(DEBUG)//这个就是定义了之后就不编译，带有条件性的
//    //这个是与上面的代码是对立面
//    printf("hehe\n");
//#endif
//    return 0;
//}

//条件编译是看被条件的代码是否有机会参与到编译之中




//////4、嵌套指令
//
//#if defined(OS_UNIX) 
//          #ifdef OPTION1 
//                   unix_version_option1();
//          #endif 
//          #ifdef OPTION2 
//                   unix_version_option2();
//          #endif 
//#elif defined(OS_MSDOS) 
//          #ifdef OPTION2 
//                   msdos_version_option2();
//          #endif 
//#endif 



//文本包含

//我们已经知道，#include指令可以使另外一个文件被编译，就像它实际出现于#include指令的地方一样。
  //这种替换的方式很简单：预处理器先删除这条指令，并用包含文件的内容进行替换。这样一个源文件
  //被包含10次，那就实际被编译10次


//#include "add.h"////头文件中放置的是函数的声明
//int main()
//{
//    int ret = Add(2, 3);
//        printf("ret=%d\n", ret);
//    return 0;
//}


//本地文件包含
//#include "filename"

//查找策略：先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标
  //准位置查找头文件。如果找不到就提示编译错误。
//VS环境的标准头文件的路径：


//这个要根据自己的安装路径进行查找


//库文件包含
//#include <filename.h>

//查找头文件直接去标准路径下去查找，如果查不到就提示编译错误
//这样是不是可以说：对于库文件也可以使用""的形式包含？答案是肯定的，可以。
//但是这样子做查找的效率低些，当然这样也不容易区分是库文件还是本地文件了。

//就是这样：
//#include "stdio.h"  //这样子查找的效率比较慢





//嵌套文件包含

//PDF中有图片例子


//嵌套文件调用最终会导致文件内容的重复

//如何解决这个问题：
//答案是：条件编译

//每个头文件的开头写：
#ifndef __TEST_H__
#define __TEST_H__
//头文件内容
#endif //__TEST_H__

//或者
#pragma once //可以理解为一次的意思
//这样就可以避免头文件的重复引入


//其他预处理指令

//#error
//#pragma
//#line
//...